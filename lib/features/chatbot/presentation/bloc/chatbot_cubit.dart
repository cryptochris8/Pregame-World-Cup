import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';

import '../../domain/entities/chat_message.dart';
import '../../domain/services/chatbot_service.dart';

// ==================== STATE ====================

abstract class ChatbotState extends Equatable {
  const ChatbotState();

  @override
  List<Object?> get props => [];
}

/// Initial state before the chat has started.
class ChatbotInitial extends ChatbotState {}

/// A response is being generated by the AI service.
class ChatbotLoading extends ChatbotState {
  final List<ChatMessage> messages;

  const ChatbotLoading({required this.messages});

  @override
  List<Object?> get props => [messages];
}

/// Chat is active with a list of messages.
class ChatbotLoaded extends ChatbotState {
  final List<ChatMessage> messages;

  const ChatbotLoaded({required this.messages});

  ChatbotLoaded copyWith({List<ChatMessage>? messages}) {
    return ChatbotLoaded(messages: messages ?? this.messages);
  }

  @override
  List<Object?> get props => [messages];
}

/// An unrecoverable error occurred.
class ChatbotError extends ChatbotState {
  final String message;
  final List<ChatMessage> previousMessages;

  const ChatbotError({
    required this.message,
    this.previousMessages = const [],
  });

  @override
  List<Object?> get props => [message, previousMessages];
}

// ==================== CUBIT ====================

/// Manages the chatbot conversation flow.
///
/// Uses [ChatbotService] to generate AI responses and maintains the
/// in-memory message list displayed in the UI. Messages are stored
/// in reverse chronological order (newest first) to match the reversed
/// ListView used in [ChatScreen].
class ChatbotCubit extends Cubit<ChatbotState> {
  final ChatbotService _chatbotService;

  ChatbotCubit({
    required ChatbotService chatbotService,
  })  : _chatbotService = chatbotService,
        super(ChatbotInitial());

  /// Start the chat session with a welcome message.
  void initialize() {
    final welcomeMessage = ChatMessage(
      text: ChatbotService.welcomeMessage,
      type: ChatMessageType.bot,
    );

    emit(ChatbotLoaded(messages: [welcomeMessage]));
  }

  /// Send a user message and generate an AI response.
  ///
  /// The user's message is added to the list immediately so the UI feels
  /// responsive. A typing indicator is shown while the AI service generates
  /// a reply. On success the indicator is replaced with the bot's response;
  /// on failure a user-friendly error message is shown instead.
  Future<void> sendMessage(String text) async {
    if (text.trim().isEmpty) return;

    final currentMessages = _getCurrentMessages();

    // Add the user's message immediately
    final userMessage = ChatMessage(
      text: text.trim(),
      type: ChatMessageType.user,
    );
    final updatedMessages = [userMessage, ...currentMessages];

    // Emit loading state with a typing indicator
    emit(ChatbotLoading(messages: updatedMessages));

    try {
      final response = await _chatbotService.getResponse(text.trim());

      final botMessage = ChatMessage(
        text: response,
        type: ChatMessageType.bot,
      );

      // Check that the cubit is still open before emitting
      if (!isClosed) {
        emit(ChatbotLoaded(messages: [botMessage, ...updatedMessages]));
      }
    } catch (e) {
      if (!isClosed) {
        // Show a friendly error as a bot message rather than breaking the UI
        final errorMessage = ChatMessage(
          text: 'Sorry, I had trouble generating a response. Please try again!',
          type: ChatMessageType.bot,
        );
        emit(ChatbotLoaded(messages: [errorMessage, ...updatedMessages]));
      }
    }
  }

  /// Clear all messages and reset the conversation.
  void clearChat() {
    _chatbotService.clearHistory();

    final welcomeMessage = ChatMessage(
      text: ChatbotService.welcomeMessage,
      type: ChatMessageType.bot,
    );

    emit(ChatbotLoaded(messages: [welcomeMessage]));
  }

  /// Extract the current message list from whatever state we are in.
  List<ChatMessage> _getCurrentMessages() {
    final current = state;
    if (current is ChatbotLoaded) return current.messages;
    if (current is ChatbotLoading) return current.messages;
    if (current is ChatbotError) return current.previousMessages;
    return [];
  }
}
